# Azure DevOps Setup Guide

This guide shows you how to set up the Boomi CI/CD CLI with Azure DevOps Pipelines.

## Prerequisites

1. **Azure DevOps Organization & Project**
2. **Self-hosted or Microsoft-hosted agent** with:
   - Bash (4.0+)
   - curl
   - jq
3. **Boomi Account Credentials**

## Setup Steps

### 1. Configure Variable Groups

Create two variable groups in Azure DevOps:

#### Variable Group: `boomicicd`
| Variable | Value | Secret |
|----------|-------|--------|
| `authToken` | Base64 encoded `BOOMI_ACCOUNT.username:token` | ✓ |
| `baseURL` | `https://api.boomi.com/api/rest/v1/ACCOUNT_ID/` | |

#### Variable Group: `boomiruntime`
| Variable | Description | Example |
|----------|-------------|---------|
| `development_apim_envname` | Development environment ID | `env-dev-123` |
| `testing_apim_envname` | UAT environment ID | `env-uat-456` |
| `production_apim_envname` | Production environment ID | `env-prod-789` |
| `testing_apim_atom` | Testing atom name | `Test-Atom-01` |

### 2. Clone Repository and Configure Pipeline

1. Clone this repository to your Azure DevOps project
2. Copy the example pipeline:
   ```bash
   cp ci-templates/azuredevops/examples/azure-pipelines.yml azure-pipelines.yml
   ```

3. Edit `azure-pipelines.yml` to configure:
   - Agent pool (`pool.name`)
   - Component IDs or process names to deploy
   - Environment settings

### 3. Pipeline Structure

The example pipeline uses a custom template that orchestrates:
- **QA Deployment** → Test → Validation
- **UAT Deployment** → Test → API Testing
- **Production Deployment** (conditional)

```yaml
trigger:
  - main

pool:
  name: 'Default'

variables:
  - group: boomicicd
  - group: boomiruntime
  - name: SCRIPTS_HOME
    value: $(Build.SourcesDirectory)/cli/scripts
  - name: WORKSPACE
    value: $(Build.SourcesDirectory)/workspace

steps:
  - script: |
      mkdir -p $(WORKSPACE)
      chmod +x $(SCRIPTS_HOME)/bin/*.sh
      chmod +x $(Build.SourcesDirectory)/ci-templates/azuredevops/pipelines/*.sh
    displayName: 'Prepare Workspace and Scripts'

  - template: ci-templates/azuredevops/pipelines/custom_deploy_pipeline.yaml
    parameters:
      packageName: 'BoomiPackage'
      packageVersion: '$(Build.BuildNumber)'
      componentIds: 'component-id-1,component-id-2'
```

### 4. Available Templates

| Template | Purpose |
|----------|---------|
| `deploy_packages.yaml` | Deploy packaged components to an environment |
| `undeploy_packages.yaml` | Undeploy packages from an environment |
| `execute_processes.yaml` | Execute processes on an atom |
| `validate_processes.yaml` | Validate process execution results |
| `call_api.yaml` | Run Postman collections for API testing |
| `custom_deploy_pipeline.yaml` | Full multi-stage pipeline (QA→UAT→Prod) |

### 5. Triggering a Deployment

1. **From Pipeline UI**: Manually trigger with parameters
2. **From Code**: Push to the configured branch (e.g., `main`)
3. **Via API**: Use Azure DevOps REST API

### 6. Monitoring

- View logs in Azure DevOps pipeline runs
- Check `$(WORKSPACE)/out.json` for API responses
- Review HTML reports generated by publish scripts

## Common Configuration Patterns

### Deploy Specific Components
```yaml
- template: ci-templates/azuredevops/pipelines/deploy_packages.yaml
  parameters:
    componentIds: 'abc-123,def-456'
    env: $(development_apim_envname)
    packageVersion: '1.0.0'
    notes: 'Hotfix deployment'
```

### Deploy by Process Name
```yaml
- template: ci-templates/azuredevops/pipelines/deploy_packages.yaml
  parameters:
    processNames: 'ProcessA,ProcessB'
    env: $(testing_apim_envname)
    packageVersion: '$(Build.BuildNumber)'
```

## Troubleshooting

### Error: `jq: command not found`
Install jq on your agent:
```bash
# Ubuntu/Debian
sudo apt-get install jq

# RHEL/CentOS
sudo yum install jq
```

### Error: Permission denied
Ensure scripts are executable:
```bash
chmod +x cli/scripts/bin/*.sh
chmod +x ci-templates/azuredevops/pipelines/*.sh
```

### Error: Authentication failed
Verify your `authToken` in the `boomicicd` variable group is correctly formatted:
```
Base64(BOOMI_ACCOUNT.username:api_token)
```

## Next Steps

- Review [CLI Reference](../../docs/CLI_REFERENCE.md) for all available commands
- Explore [Common Workflows](../../examples/common-workflows/) for more patterns
- Customize templates for your specific deployment strategy

---

## Advanced: Using the Custom Deployment Pipeline

The `custom_deploy_pipeline.yaml` template provides a **production-ready, multi-stage deployment pipeline** with automated testing and API validation.

### Pipeline Stages

The custom pipeline orchestrates deployments through multiple environments:

```
Preparation → QA → UAT → Production
    ↓          ↓     ↓         ↓
Get Components → Deploy → Deploy → Deploy
                 ↓        ↓
                Test    Test
                 ↓        ↓
              API Test  API Test
                         ↓
                   Emulator Test
```

**Stages:**
1. **Preparation**: Retrieves component IDs from Boomi
2. **QA_Deployment**: Deploys to development/QA environment
3. **QA_Testing**: Executes test processes
4. **QA_APITesting**: Runs Postman collections
5. **UAT_Deployment**: Deploys to UAT environment
6. **UAT_Testing**: Executes UAT test processes
7. **UAT_APITesting**: Runs UAT API tests
8. **UAT_Completion**: Final emulator tests
9. **Prod_Deployment**: Deploys to production (with approval)
10. **Test_Testing_Teardown**: Cleanup (always runs)

### Example: dummy-api.yaml

The `examples/dummy-api.yaml` demonstrates how to extend the custom pipeline:

```yaml
#####################################
# Deployment Pipeline for Dummy API #
#####################################

parameters:
  - name: packageVersion
    displayName: Package Version (0 for new, or Build Number to reuse)
    type: string
    default: 0
  - name: notes
    displayName: Notes
    type: string
    default: 'Dummy API Bundle'
  - name: deployToQA
    displayName: Deploy to QA
    type: boolean
    default: false
  - name: deployToUAT
    displayName: Deploy to UAT
    type: boolean
    default: false
  - name: deployToProd
    displayName: Deploy to Production
    type: boolean
    default: false
  - name: branchName
    displayName: Branch Name
    type: string
    default: 'master'

trigger:
  - master

pool:
  name: Default
  demands:
    - agent.os -equals Linux

# Extend the custom deployment template
extends:
  template: templates/custom_deploy_pipeline.yaml
  parameters:
    packageVersion: ${{ parameters.packageVersion }}
    packageName: 'dummy-api'
    componentIds: '2d72456d-baa8-4782-beb6-e18511bf9feb,ea579547-3b49-4881-9ed6-156d27ac38db'
    test_componentIds: '4fd96edb-18c6-4436-8444-be99c4e91b67'
    notes: ${{ parameters.notes }}
    deployToQA: ${{ parameters.deployToQA }}
    deployToUAT: ${{ parameters.deployToUAT }}
    deployToProd: ${{ parameters.deployToProd }}
    postmanCollection: 'dummy-api-basic-postman.json'
    sleepInMinutes: 1
    branchName: ${{ parameters.branchName }}
```

### How It Works

#### 1. Pipeline Parameters

The template accepts runtime parameters:
- **packageVersion**: `0` creates new package; otherwise reuses existing
- **deployToQA/UAT/Prod**: Boolean flags to control which stages run
- **componentIds**: Main components to deploy
- **test_componentIds**: Test/validation components
- **postmanCollection**: API tests (optional)

#### 2. Template Extension

The `extends` keyword inherits all stages from `custom_deploy_pipeline.yaml`:

```yaml
extends:
  template: templates/custom_deploy_pipeline.yaml
  parameters:
    # Your specific configuration
```

This gives you:
- ✅ Multi-environment deployment
- ✅ Automated testing between stages
- ✅ API validation with Postman
- ✅ Cleanup after execution

#### 3. Conditional Execution

Stages execute conditionally based on parameters:

```yaml
# In custom_deploy_pipeline.yaml
- ${{ if eq(parameters['deployToQA'], 'true') }}:
    - stage: QA_Deployment
      # ...

- ${{ if eq(parameters['deployToUAT'], 'true') }}:
    - stage: UAT_Deployment
      # ...

- ${{ if eq(parameters['deployToProd'], 'true') }}:
    - stage: Prod_Deployment
      # ...
```

**Example execution:**
- `deployToQA=true, deployToUAT=false, deployToProd=false` → Only QA stages run
- `deployToUAT=true, deployToProd=true` → UAT and Prod stages run (QA skipped)

### Creating Your Own Pipeline

1. **Copy the example:**
   ```bash
   cp ci-templates/azuredevops/examples/dummy-api.yaml my-api.yaml
   ```

2. **Update parameters:**
   ```yaml
   parameters:
     packageVersion: ${{ parameters.packageVersion }}
     packageName: 'my-api-name'
     componentIds: 'your-component-id-1,your-component-id-2'
     test_componentIds: 'your-test-component-id'
     postmanCollection: 'my-api-tests.json'  # Optional
     notes: ${{ parameters.notes }}
     deployToQA: ${{ parameters.deployToQA }}
     deployToUAT: ${{ parameters.deployToUAT }}
     deployToProd: ${{ parameters.deployToProd }}
   ```

3. **Find component IDs:**
   ```bash
   export authToken="..."
   export baseURL="..."
   source cli/scripts/bin/queryProcess.sh processName="*"
   # Copy component IDs from output
   ```

4. **Commit and push:**
   ```bash
   git add my-api.yaml
   git commit -m "Add my-api deployment pipeline"
   git push
   ```

5. **Create pipeline in Azure DevOps:**
   - Go to **Pipelines** → **New Pipeline**
   - Select repository
   - Choose **Existing Azure Pipelines YAML file**
   - Path: `/my-api.yaml`
   - **Run**

---

## Configuring Approvals and Gates

For production deployments, you should configure **manual approvals** to prevent accidental deployments.

### 1. Enable Environments

Environments provide deployment tracking and approval gates:

1. Navigate to **Pipelines** → **Environments**
2. Click **New environment**
3. Create environments:
   - `QA` or `Development`
   - `UAT` or `Testing`
   - `Production`

### 2. Configure Approval Checks

For the **Production** environment:

1. Go to **Pipelines** → **Environments** → **Production**
2. Click the **⋮** menu → **Approvals and checks**
3. Click **+** → **Approvals**

**Configure approvers:**
- **Approvers**: Add users or groups (e.g., "Release Managers", "Prod Approvers")
- **Minimum number of approvers**: `1` (or more for critical systems)
- **Timeout**: `30 days` (pipeline waits this long for approval)
- **Instructions**: Add guidance like "Review test results before approving"

4. Click **Create**

### 3. Add Environment to Pipeline

Update your pipeline to reference the environment:

**Option A: Modify custom_deploy_pipeline.yaml**

Add `environment` to the Prod_Deployment stage:

```yaml
- stage: Prod_Deployment
  dependsOn: UAT_Completion
  jobs:
    - deployment: deploy_to_production
      environment: Production  # Links to Environment for approval
      variables:
        componentIds: $[stageDependencies.Preparation.get_components.outputs['output_variable.componentIds']]
      strategy:
        runOnce:
          deploy:
            steps:
              - template: deploy_packages.yaml
                parameters:
                  # ... existing parameters
```

**Option B: Add approval in your pipeline** (dummy-api.yaml)

For finer control, wrap stages with deployment jobs:

```yaml
extends:
  template: templates/custom_deploy_pipeline.yaml
  parameters:
    # ... your parameters

# Override or extend stages for approval
stages:
  - stage: Approve_Production
    dependsOn: UAT_Completion
    jobs:
      - deployment: approve_prod
        displayName: 'Approve Production Deployment'
        environment: Production  # Requires approval
        strategy:
          runOnce:
            deploy:
              steps:
                - script: echo "Approved for production"
```

### 4. Configure Additional Checks

Beyond manual approval, add automated gates:

#### Business Hours Check

Restrict deployments to business hours:

1. Environment → **Approvals and checks** → **+** → **Business hours**
2. Configure:
   - **Time zone**: Your timezone
   - **Days**: Monday - Friday
   - **Start time**: 9:00 AM
   - **End time**: 5:00 PM

#### Branch Control

Ensure only specific branches deploy to production:

1. Environment → **Approvals and checks** → **+** → **Branch control**
2. **Allowed branches**: `refs/heads/main`, `refs/heads/release/*`

#### Required Template Check

Enforce use of approved pipeline templates:

1. Environment → **Approvals and checks** → **+** → **Required template**
2. Specify: `ci-templates/azuredevops/pipelines/custom_deploy_pipeline.yaml@main`

### 5. Approval Workflow

When a pipeline reaches Production stage:

1. Pipeline **pauses** at the deployment
2. **Approvers receive notification** (email + Azure DevOps)
3. Approver reviews:
   - **Test results** from QA/UAT
   - **API test reports**
   - **Change notes**
4. Approver clicks **Review** → **Approve** or **Reject**
5. If approved, deployment proceeds
6. If rejected, pipeline fails with approver's comment

**Approval UI:**
```
Production deployment is waiting for review
├─ Environment: Production
├─ Requested by: John Doe
├─ Pipeline: dummy-api #123
├─ Branch: main
└─ [Approve] [Reject] [Reassign]
```

### 6. Role-Based Approvals

Configure who can approve based on Azure AD groups:

**Create Approval Groups:**

1. **Azure Active Directory** → **Groups** → **New group**
2. Create groups:
   - `Boomi-QA-Approvers` (for QA deployments)
   - `Boomi-UAT-Approvers` (for UAT deployments)
   - `Boomi-Prod-Approvers` (for production deployments)

**Assign to Environments:**

1. Navigate to **Production** environment
2. **Approvals and checks** → **Approvals** → **Edit**
3. **Approvers**: Add `Boomi-Prod-Approvers` group
4. Set **Minimum number of approvers** based on risk:
   - Critical systems: `2` approvers
   - Standard systems: `1` approver

**Environment Permissions:**

1. Environment → **⋮** → **Security**
2. Add groups with specific permissions:
   - `Boomi-Prod-Approvers`: **Approver** role
   - `Boomi-Developers`: **Reader** role (view only)
   - `Boomi-Release-Managers`: **Administrator** role

### 7. Approval Notifications

Configure notifications for approval requests:

1. **Project Settings** → **Notifications**
2. **New subscription** → **Build and release**
3. Choose: **Deployment pending**
4. Add recipients: Approval groups or individuals
5. **Save**

### 8. Best Practices

✅ **Multiple Approvers for Prod**: Require 2+ approvals for production

✅ **Separate Approval Groups**: Different groups for QA/UAT/Prod

✅ **Time Windows**: Restrict prod deployments to business hours or maintenance windows

✅ **Audit Trail**: Azure DevOps logs all approvals with timestamp and approver

✅ **Approval Timeout**: Set realistic timeouts (24-48 hours for prod)

✅ **Reject with Comments**: Approvers should document rejection reasons

✅ **Post-Deployment Validation**: Add monitoring checks after production deployment

### 9. Example: Complete Approval Flow

```
Developer pushes to main branch
        ↓
Pipeline triggers automatically
        ↓
Preparation stage: Get components
        ↓
[Manual trigger: deployToQA=true]
        ↓
QA_Deployment: Deploy to QA
        ↓
QA_Testing: Run tests
        ↓
QA_APITesting: Validate APIs
        ↓
[Manual trigger: deployToUAT=true]
        ↓
UAT_Deployment: Deploy to UAT
        ↓
UAT_Testing: Run UAT tests
        ↓
UAT_APITesting: Validate UAT APIs
        ↓
UAT_Completion: Emulator tests
        ↓
[Manual trigger: deployToProd=true]
        ↓
⏸️  PAUSED: Waiting for Production approval
        ↓
Email sent to Boomi-Prod-Approvers group
        ↓
Approver reviews test results
        ↓
Approver clicks "Approve"
        ↓
Prod_Deployment: Deploy to production
        ↓
Cleanup: Test_Testing_Teardown
        ↓
✅ Pipeline completed
```

### 10. Troubleshooting Approvals

**Approval not triggered:**
- Verify `environment: Production` is set in deployment job
- Check environment exists in Azure DevOps
- Ensure stage dependencies are correct

**Approvers not notified:**
- Check notification settings
- Verify approvers have permissions
- Check spam/junk folders for emails

**Deployment skipped:**
- Verify `deployToProd` parameter is `true`
- Check conditional expressions in template
- Review stage dependencies

---

## Next Steps
